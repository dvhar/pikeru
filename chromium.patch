diff --git a/ui/shell_dialogs/BUILD.gn b/ui/shell_dialogs/BUILD.gn
index b14a028899..70407b9efa 100644
--- a/ui/shell_dialogs/BUILD.gn
+++ b/ui/shell_dialogs/BUILD.gn
@@ -49,6 +49,8 @@ component("shell_dialogs") {
     sources += [
       "select_file_dialog_linux.cc",
       "select_file_dialog_linux.h",
+      "select_file_dialog_linux_custom.cc",
+      "select_file_dialog_linux_custom.h",
       "select_file_dialog_linux_kde.cc",
       "select_file_dialog_linux_kde.h",
       "shell_dialog_linux.cc",
diff --git a/ui/shell_dialogs/select_file_dialog_linux_custom.cc b/ui/shell_dialogs/select_file_dialog_linux_custom.cc
new file mode 100644
index 0000000000..c3325a5e2b
--- /dev/null
+++ b/ui/shell_dialogs/select_file_dialog_linux_custom.cc
@@ -0,0 +1,585 @@
+// Copyright 2012 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the chromium LICENSE file.
+
+#include <cstddef>
+#include <iostream>
+#include <memory>
+#include <set>
+
+#include "base/command_line.h"
+#include "base/functional/bind.h"
+#include "base/logging.h"
+#include "base/nix/mime_util_xdg.h"
+#include "base/nix/xdg_util.h"
+#include "base/process/launch.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_split.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/task/sequenced_task_runner.h"
+#include "base/task/task_traits.h"
+#include "base/task/thread_pool.h"
+#include "base/threading/thread_restrictions.h"
+#include "ui/aura/window_tree_host.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/shell_dialogs/select_file_dialog_linux.h"
+#include "ui/shell_dialogs/select_file_dialog_linux_custom.h"
+#include "ui/shell_dialogs/selected_file_info.h"
+#include "ui/strings/grit/ui_strings.h"
+#include "url/gurl.h"
+
+namespace {
+
+std::string GetTitle(const std::string& title, int message_id) {
+  return title.empty() ? l10n_util::GetStringUTF8(message_id) : title;
+}
+
+}  // namespace
+
+namespace ui {
+
+// Implementation of SelectFileDialog that shows a custom dialog for choosing a
+// file or folder set by the kCustomPicker environment variable. This acts as a
+// modal dialog.
+class SelectFileDialogLinuxCustom : public SelectFileDialogLinux {
+ public:
+  SelectFileDialogLinuxCustom(Listener* listener,
+                           std::unique_ptr<ui::SelectFilePolicy> policy);
+
+  SelectFileDialogLinuxCustom(const SelectFileDialogLinuxCustom&) = delete;
+  SelectFileDialogLinuxCustom& operator=(const SelectFileDialogLinuxCustom&) = delete;
+
+ protected:
+  ~SelectFileDialogLinuxCustom() override;
+
+  // BaseShellDialog implementation:
+  bool IsRunning(gfx::NativeWindow parent_window) const override;
+
+  // SelectFileDialog implementation.
+  // |params| is user data we pass back via the Listener interface.
+  void SelectFileImpl(Type type,
+                      const std::u16string& title,
+                      const base::FilePath& default_path,
+                      const FileTypeInfo* file_types,
+                      int file_type_index,
+                      const base::FilePath::StringType& default_extension,
+                      gfx::NativeWindow owning_window,
+                      void* params,
+                      const GURL* caller) override;
+
+ private:
+  bool HasMultipleFileTypeChoicesImpl() override;
+
+  struct CustomDialogParams {
+    CustomDialogParams(const std::string& type,
+                  const std::string& title,
+                  const base::FilePath& default_path,
+                  gfx::AcceleratedWidget parent,
+                  bool file_operation,
+                  bool multiple_selection)
+        : type(type),
+          title(title),
+          default_path(default_path),
+          parent(parent),
+          file_operation(file_operation),
+          multiple_selection(multiple_selection) {}
+
+    std::string type;
+    std::string title;
+    base::FilePath default_path;
+    gfx::AcceleratedWidget parent;
+    bool file_operation;
+    bool multiple_selection;
+  };
+
+  struct CustomDialogOutputParams {
+    std::string output;
+    int exit_code;
+  };
+
+  // Get the filters from |file_types_| and concatenate them into
+  // |filter_string|.
+  std::string GetMimeTypeFilterString();
+
+  void GetCommandLineArgs(const std::string& type,
+                             const std::string& title,
+                             const base::FilePath& default_path,
+                             gfx::AcceleratedWidget parent,
+                             bool file_operation,
+                             bool multiple_selection,
+                             base::CommandLine* command_line);
+
+  // Call a filepicker on the FILE thread and return the results.
+  std::unique_ptr<CustomDialogOutputParams> CallCustomDialogOutput(
+      const CustomDialogParams& params);
+
+  // Notifies the listener that a single file was chosen.
+  void FileSelected(const base::FilePath& path, void* params);
+
+  // Notifies the listener that multiple files were chosen.
+  void MultiFilesSelected(const std::vector<base::FilePath>& files,
+                          void* params);
+
+  // Notifies the listener that no file was chosen (the action was canceled).
+  // Dialog is passed so we can find that |params| pointer that was passed to
+  // us when we were told to show the dialog.
+  void FileNotSelected(void* params);
+
+  void CreateSelectFolderDialog(Type type,
+                                const std::string& title,
+                                const base::FilePath& default_path,
+                                gfx::AcceleratedWidget parent,
+                                void* params);
+
+  void CreateFileOpenDialog(const std::string& title,
+                            const base::FilePath& default_path,
+                            gfx::AcceleratedWidget parent,
+                            void* params);
+
+  void CreateMultiFileOpenDialog(const std::string& title,
+                                 const base::FilePath& default_path,
+                                 gfx::AcceleratedWidget parent,
+                                 void* params);
+
+  void CreateSaveAsDialog(const std::string& title,
+                          const base::FilePath& default_path,
+                          gfx::AcceleratedWidget parent,
+                          void* params);
+
+  // Common function for OnSelectSingleFileDialogResponse and
+  // OnSelectSingleFolderDialogResponse.
+  void SelectSingleFileHelper(void* params,
+                              bool allow_folder,
+                              std::unique_ptr<CustomDialogOutputParams> results);
+
+  void OnSelectSingleFileDialogResponse(
+      gfx::AcceleratedWidget parent,
+      void* params,
+      std::unique_ptr<CustomDialogOutputParams> results);
+  void OnSelectMultiFileDialogResponse(
+      gfx::AcceleratedWidget parent,
+      void* params,
+      std::unique_ptr<CustomDialogOutputParams> results);
+  void OnSelectSingleFolderDialogResponse(
+      gfx::AcceleratedWidget parent,
+      void* params,
+      std::unique_ptr<CustomDialogOutputParams> results);
+
+  // The set of all parent windows for which we are currently running
+  // dialogs. This should only be accessed on the UI thread.
+  std::set<gfx::AcceleratedWidget> parents_;
+
+  // Set to true if the filepicker supports passing
+  // multiple extensions with descriptions, eliminating the need for the lossy
+  // conversion of extensions to mime-types.
+  bool dialog_supports_multiple_extensions_ = false;
+
+  // A task runner for blocking pipe reads.
+  scoped_refptr<base::SequencedTaskRunner> pipe_task_runner_;
+
+  SEQUENCE_CHECKER(sequence_checker_);
+};
+
+SelectFileDialog* NewSelectFileDialogLinuxCustom(
+    SelectFileDialog::Listener* listener,
+    std::unique_ptr<ui::SelectFilePolicy> policy) {
+  return new SelectFileDialogLinuxCustom(listener, std::move(policy));
+}
+
+SelectFileDialogLinuxCustom::SelectFileDialogLinuxCustom(
+    Listener* listener, std::unique_ptr<ui::SelectFilePolicy> policy)
+    : SelectFileDialogLinux(listener, std::move(policy)),
+      pipe_task_runner_(base::ThreadPool::CreateSequencedTaskRunner(
+          {base::MayBlock(), base::TaskPriority::USER_BLOCKING,
+           base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN})) {
+}
+
+SelectFileDialogLinuxCustom::~SelectFileDialogLinuxCustom() = default;
+
+bool SelectFileDialogLinuxCustom::IsRunning(
+    gfx::NativeWindow parent_window) const {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (parent_window && parent_window->GetHost()) {
+    auto window = parent_window->GetHost()->GetAcceleratedWidget();
+    return parents_.find(window) != parents_.end();
+  }
+
+  return false;
+}
+
+// We ignore |default_extension|.
+void SelectFileDialogLinuxCustom::SelectFileImpl(
+    Type type,
+    const std::u16string& title,
+    const base::FilePath& default_path,
+    const FileTypeInfo* file_types,
+    int file_type_index,
+    const base::FilePath::StringType& default_extension,
+    gfx::NativeWindow owning_window,
+    void* params,
+    const GURL* caller) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  set_type(type);
+
+  gfx::AcceleratedWidget window = gfx::kNullAcceleratedWidget;
+  if (owning_window && owning_window->GetHost()) {
+    // |owning_window| can be null when user right-clicks on a downloadable item
+    // and chooses 'Open Link in New Tab' when 'Ask where to save each file
+    // before downloading.' preference is turned on. (http://crbug.com/29213)
+    window = owning_window->GetHost()->GetAcceleratedWidget();
+    parents_.insert(window);
+  }
+
+  std::string title_string = base::UTF16ToUTF8(title);
+
+  set_file_type_index(file_type_index);
+  if (file_types) {
+    set_file_types(*file_types);
+  } else {
+    auto file_types_copy = SelectFileDialogLinux::file_types();
+    file_types_copy.include_all_files = true;
+    set_file_types(file_types_copy);
+  }
+
+  switch (type) {
+    case SELECT_FOLDER:
+    case SELECT_UPLOAD_FOLDER:
+    case SELECT_EXISTING_FOLDER:
+      CreateSelectFolderDialog(type, title_string, default_path, window,
+                               params);
+      return;
+    case SELECT_OPEN_FILE:
+      CreateFileOpenDialog(title_string, default_path, window, params);
+      return;
+    case SELECT_OPEN_MULTI_FILE:
+      CreateMultiFileOpenDialog(title_string, default_path, window, params);
+      return;
+    case SELECT_SAVEAS_FILE:
+      CreateSaveAsDialog(title_string, default_path, window, params);
+      return;
+    case SELECT_NONE:
+      NOTREACHED();
+      return;
+  }
+}
+
+bool SelectFileDialogLinuxCustom::HasMultipleFileTypeChoicesImpl() {
+  return file_types().extensions.size() > 1;
+}
+
+std::string SelectFileDialogLinuxCustom::GetMimeTypeFilterString() {
+  DCHECK(pipe_task_runner_->RunsTasksInCurrentSequence());
+
+  if (!dialog_supports_multiple_extensions_) {
+    // We need a filter set because the same mime type can appear multiple
+    // times.
+    std::set<std::string> filter_set;
+    for (auto& extensions : file_types().extensions) {
+      for (auto& extension : extensions) {
+        if (!extension.empty()) {
+          std::string mime_type = base::nix::GetFileMimeType(
+              base::FilePath("name").ReplaceExtension(extension));
+          filter_set.insert(mime_type);
+        }
+      }
+    }
+    std::vector<std::string> filter_vector(filter_set.cbegin(),
+                                           filter_set.cend());
+    // Add the *.* filter, but only if we have added other filters (otherwise it
+    // is implied). It needs to be added last to avoid being picked as the
+    // default filter.
+    if (file_types().include_all_files && !file_types().extensions.empty()) {
+      DCHECK(filter_set.find("application/octet-stream") == filter_set.end());
+      filter_vector.push_back("application/octet-stream");
+    }
+    return base::JoinString(filter_vector, " ");
+  }
+
+  std::vector<std::string> filters;
+  for (size_t i = 0; i < file_types().extensions.size(); ++i) {
+    std::set<std::string> extension_filters;
+    for (const auto& extension : file_types().extensions[i]) {
+      if (extension.empty())
+        continue;
+      extension_filters.insert(std::string("*.") + extension);
+    }
+
+    // We didn't find any non-empty extensions to filter on.
+    if (extension_filters.empty())
+      continue;
+
+    std::vector<std::string> extension_filters_vector(extension_filters.begin(),
+                                                      extension_filters.end());
+
+    std::string description;
+    // The description vector may be blank, in which case we are supposed to
+    // use some sort of default description based on the filter.
+    if (i < file_types().extension_description_overrides.size()) {
+      description =
+          base::UTF16ToUTF8(file_types().extension_description_overrides[i]);
+      // Filter out any characters that would mess up the dialog's parsing.
+      base::ReplaceChars(description, "|()", "", &description);
+    } else {
+      // There is no system default filter description so we use
+      // the extensions themselves if the description is blank.
+      description = base::JoinString(extension_filters_vector, ",");
+    }
+
+    filters.push_back(description + " (" +
+                      base::JoinString(extension_filters_vector, " ") + ")");
+  }
+
+  if (file_types().include_all_files && !file_types().extensions.empty())
+    filters.push_back(l10n_util::GetStringUTF8(IDS_SAVEAS_ALL_FILES) + " (*)");
+
+  return base::JoinString(filters, "|");
+}
+
+std::unique_ptr<SelectFileDialogLinuxCustom::CustomDialogOutputParams>
+SelectFileDialogLinuxCustom::CallCustomDialogOutput(const CustomDialogParams& params) {
+  DCHECK(pipe_task_runner_->RunsTasksInCurrentSequence());
+  base::CommandLine::StringVector cmd_vector;
+  cmd_vector.push_back(getenv(kCustomPickerEnv));
+  base::CommandLine command_line(cmd_vector);
+  GetCommandLineArgs(params.type, params.title, params.default_path,
+                        params.parent, params.file_operation,
+                        params.multiple_selection, &command_line);
+
+  LOG(INFO) << "Custom filepicker command:" << command_line.GetCommandLineString() << std::endl;
+
+  auto results = std::make_unique<CustomDialogOutputParams>();
+  // Get output from the dialog
+  base::GetAppOutputWithExitCode(command_line, &results->output,
+                                 &results->exit_code);
+
+  if (results->exit_code != 0) {
+    LOG(INFO) << "Custom filepicker usage:\n"
+      "Set the $" << kCustomPickerEnv << " environment variable to an executable"
+      " that takes these cmdline arguments and prints the selected files to stdout:\n"
+      "	-e PARENT_WINDOW:	browser window to embed the filepicker into\n"
+      "	-t TITLE:	title of the filepicker window\n"
+      "	-k TYPE:	type of file selection. One of [file files dir save]\n"
+      "	-p PATH:	path of initial directory\n"
+      "	-i MIME_LIST:	list of allowed mime types. Can be empty.";
+  }
+
+  if (!results->output.empty())
+    results->output.erase(results->output.size() - 1);
+  return results;
+}
+
+void SelectFileDialogLinuxCustom::GetCommandLineArgs(
+    const std::string& type,
+    const std::string& title,
+    const base::FilePath& path,
+    gfx::AcceleratedWidget parent,
+    bool file_operation,
+    bool multiple_selection,
+    base::CommandLine* command_line) {
+  CHECK(command_line);
+
+  // Attach to the current Chrome window.
+  if (parent != gfx::kNullAcceleratedWidget) {
+    command_line->AppendArg("-e");
+    command_line->AppendArg(base::NumberToString(static_cast<uint32_t>(parent)));
+  }
+
+  // Set the correct title for the dialog.
+  if (!title.empty()){
+    command_line->AppendArg("-t");
+    command_line->AppendArg(title);
+  }
+  command_line->AppendArg("-k");
+  command_line->AppendArg(type);
+  // The path should never be empty. If it is, set it to PWD.
+  command_line->AppendArg("-p");
+  if (path.empty())
+    command_line->AppendArgPath(base::FilePath("."));
+  else
+    command_line->AppendArgPath(path);
+  // Depending on the type of the operation we need, get the path to the
+  // file/folder and set up mime type filters.
+  if (file_operation) {
+    command_line->AppendArg("-i");
+    command_line->AppendArg(GetMimeTypeFilterString());
+  }
+}
+
+void SelectFileDialogLinuxCustom::FileSelected(const base::FilePath& path,
+                                            void* params) {
+  if (type() == SELECT_SAVEAS_FILE)
+    set_last_saved_path(path.DirName());
+  else if (type() == SELECT_OPEN_FILE)
+    set_last_opened_path(path.DirName());
+  else if (type() == SELECT_FOLDER || type() == SELECT_UPLOAD_FOLDER ||
+           type() == SELECT_EXISTING_FOLDER)
+    set_last_opened_path(path);
+  else
+    NOTREACHED();
+  if (listener_) {  // What does the filter index actually do?
+    // TODO(dfilimon): Get a reasonable index value from somewhere.
+    listener_->FileSelected(SelectedFileInfo(path), 1, params);
+  }
+}
+
+void SelectFileDialogLinuxCustom::MultiFilesSelected(
+    const std::vector<base::FilePath>& files,
+    void* params) {
+  set_last_opened_path(files[0].DirName());
+  if (listener_)
+    listener_->MultiFilesSelected(FilePathListToSelectedFileInfoList(files), params);
+}
+
+void SelectFileDialogLinuxCustom::FileNotSelected(void* params) {
+  if (listener_)
+    listener_->FileSelectionCanceled(params);
+}
+
+void SelectFileDialogLinuxCustom::CreateSelectFolderDialog(
+    Type type,
+    const std::string& title,
+    const base::FilePath& default_path,
+    gfx::AcceleratedWidget parent,
+    void* params) {
+  int title_message_id = (type == SELECT_UPLOAD_FOLDER)
+                             ? IDS_SELECT_UPLOAD_FOLDER_DIALOG_TITLE
+                             : IDS_SELECT_FOLDER_DIALOG_TITLE;
+  pipe_task_runner_->PostTaskAndReplyWithResult(
+      FROM_HERE,
+      base::BindOnce(
+          &SelectFileDialogLinuxCustom::CallCustomDialogOutput, this,
+          CustomDialogParams(
+              "dir", GetTitle(title, title_message_id),
+              default_path.empty() ? *last_opened_path() : default_path, parent,
+              false, false)),
+      base::BindOnce(
+          &SelectFileDialogLinuxCustom::OnSelectSingleFolderDialogResponse, this,
+          parent, params));
+}
+
+void SelectFileDialogLinuxCustom::CreateFileOpenDialog(
+    const std::string& title,
+    const base::FilePath& default_path,
+    gfx::AcceleratedWidget parent,
+    void* params) {
+  pipe_task_runner_->PostTaskAndReplyWithResult(
+      FROM_HERE,
+      base::BindOnce(
+          &SelectFileDialogLinuxCustom::CallCustomDialogOutput, this,
+          CustomDialogParams(
+              "file", GetTitle(title, IDS_OPEN_FILE_DIALOG_TITLE),
+              default_path.empty() ? *last_opened_path() : default_path, parent,
+              true, false)),
+      base::BindOnce(
+          &SelectFileDialogLinuxCustom::OnSelectSingleFileDialogResponse, this,
+          parent, params));
+}
+
+void SelectFileDialogLinuxCustom::CreateMultiFileOpenDialog(
+    const std::string& title,
+    const base::FilePath& default_path,
+    gfx::AcceleratedWidget parent,
+    void* params) {
+  pipe_task_runner_->PostTaskAndReplyWithResult(
+      FROM_HERE,
+      base::BindOnce(
+          &SelectFileDialogLinuxCustom::CallCustomDialogOutput, this,
+          CustomDialogParams(
+              "files", GetTitle(title, IDS_OPEN_FILES_DIALOG_TITLE),
+              default_path.empty() ? *last_opened_path() : default_path, parent,
+              true, true)),
+      base::BindOnce(&SelectFileDialogLinuxCustom::OnSelectMultiFileDialogResponse,
+                     this, parent, params));
+}
+
+void SelectFileDialogLinuxCustom::CreateSaveAsDialog(
+    const std::string& title,
+    const base::FilePath& default_path,
+    gfx::AcceleratedWidget parent,
+    void* params) {
+  pipe_task_runner_->PostTaskAndReplyWithResult(
+      FROM_HERE,
+      base::BindOnce(
+          &SelectFileDialogLinuxCustom::CallCustomDialogOutput, this,
+          CustomDialogParams(
+              "save", GetTitle(title, IDS_SAVE_AS_DIALOG_TITLE),
+              default_path.empty() ? *last_saved_path() : default_path, parent,
+              true, false)),
+      base::BindOnce(
+          &SelectFileDialogLinuxCustom::OnSelectSingleFileDialogResponse, this,
+          parent, params));
+}
+
+void SelectFileDialogLinuxCustom::SelectSingleFileHelper(
+    void* params,
+    bool allow_folder,
+    std::unique_ptr<CustomDialogOutputParams> results) {
+  VLOG(1) << "[file picker dialog] SingleFileResponse: " << results->output;
+  if (results->exit_code || results->output.empty()) {
+    FileNotSelected(params);
+    return;
+  }
+
+  base::FilePath path(results->output);
+  if (allow_folder) {
+    FileSelected(path, params);
+    return;
+  }
+
+  if (CallDirectoryExistsOnUIThread(path))
+    FileNotSelected(params);
+  else
+    FileSelected(path, params);
+}
+
+void SelectFileDialogLinuxCustom::OnSelectSingleFileDialogResponse(
+    gfx::AcceleratedWidget parent,
+    void* params,
+    std::unique_ptr<CustomDialogOutputParams> results) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  parents_.erase(parent);
+  SelectSingleFileHelper(params, false, std::move(results));
+}
+
+void SelectFileDialogLinuxCustom::OnSelectSingleFolderDialogResponse(
+    gfx::AcceleratedWidget parent,
+    void* params,
+    std::unique_ptr<CustomDialogOutputParams> results) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  parents_.erase(parent);
+  SelectSingleFileHelper(params, true, std::move(results));
+}
+
+void SelectFileDialogLinuxCustom::OnSelectMultiFileDialogResponse(
+    gfx::AcceleratedWidget parent,
+    void* params,
+    std::unique_ptr<CustomDialogOutputParams> results) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  VLOG(1) << "[file picker dialog] MultiFileResponse: " << results->output;
+
+  parents_.erase(parent);
+
+  if (results->exit_code || results->output.empty()) {
+    FileNotSelected(params);
+    return;
+  }
+
+  std::vector<base::FilePath> filenames_fp;
+  for (const base::StringPiece& line :
+       base::SplitStringPiece(results->output, "\n", base::KEEP_WHITESPACE,
+                              base::SPLIT_WANT_NONEMPTY)) {
+    base::FilePath path(line);
+    if (CallDirectoryExistsOnUIThread(path))
+      continue;
+    filenames_fp.push_back(path);
+  }
+
+  if (filenames_fp.empty()) {
+    FileNotSelected(params);
+    return;
+  }
+  MultiFilesSelected(filenames_fp, params);
+}
+
+}  // namespace ui
diff --git a/ui/shell_dialogs/select_file_dialog_linux_custom.h b/ui/shell_dialogs/select_file_dialog_linux_custom.h
new file mode 100644
index 0000000000..b3c677b63a
--- /dev/null
+++ b/ui/shell_dialogs/select_file_dialog_linux_custom.h
@@ -0,0 +1,23 @@
+#ifndef UI_SHELL_DIALOGS_SELECT_FILE_DIALOG_LINUX_CUSTOM_H_
+#define UI_SHELL_DIALOGS_SELECT_FILE_DIALOG_LINUX_CUSTOM_H_
+
+#include <string>
+
+#include "base/nix/xdg_util.h"
+#include "ui/shell_dialogs/select_file_dialog.h"
+
+namespace ui {
+
+class SelectFileDialog;
+
+SelectFileDialog* NewSelectFileDialogLinuxCustom(
+    SelectFileDialog::Listener* listener,
+    std::unique_ptr<ui::SelectFilePolicy> policy);
+
+}  // namespace ui
+
+namespace {
+	const char* kCustomPickerEnv = "CUSTOM_FILEPICKER";
+}
+
+#endif  // UI_SHELL_DIALOGS_SELECT_FILE_DIALOG_LINUX_CUSTOM_H_
diff --git a/ui/shell_dialogs/shell_dialog_linux.cc b/ui/shell_dialogs/shell_dialog_linux.cc
index 6086d6efdf..5539c51253 100644
--- a/ui/shell_dialogs/shell_dialog_linux.cc
+++ b/ui/shell_dialogs/shell_dialog_linux.cc
@@ -11,6 +11,7 @@
 #include "ui/linux/linux_ui.h"
 #include "ui/shell_dialogs/select_file_dialog_linux.h"
 #include "ui/shell_dialogs/select_file_dialog_linux_kde.h"
+#include "ui/shell_dialogs/select_file_dialog_linux_custom.h"
 #include "ui/shell_dialogs/select_file_policy.h"
 
 #if defined(USE_DBUS)
@@ -44,6 +45,7 @@ enum FileDialogChoice {
 #if defined(USE_DBUS)
   kPortal,
 #endif
+  kCustom,
 };
 
 FileDialogChoice dialog_choice_ = kUnknown;
@@ -54,6 +56,9 @@ std::string& KDialogVersion() {
 }
 
 FileDialogChoice GetFileDialogChoice() {
+	if (getenv(kCustomPickerEnv)) {
+		return kCustom;
+	}
 #if defined(USE_DBUS)
   // Check to see if the portal is available.
   if (SelectFileDialogLinuxPortal::IsPortalAvailable())
@@ -108,6 +113,8 @@ SelectFileDialog* CreateSelectFileDialog(
       return NewSelectFileDialogLinuxKde(listener, std::move(policy), desktop,
                                          KDialogVersion());
     }
+	case kCustom:
+	  return NewSelectFileDialogLinuxCustom(listener, std::move(policy));
     case kUnknown:
       NOTREACHED();
   }
